<!doctype html>
<html lang="en">
<head>
<title>Dasifefe - Game development update - good performance rendering like the SNES</title>
<meta name="autor" content="Felipe Ferreira da Silva">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="./style.css">
<link rel="icon" href="./favicon.ico">
</head>
<body>	
<header>
<h1><a href="./index.html">Dasifefe</a></h1>
<p>Programmer, biologist and illustrator.</p>
</header>
<article>
<h1>Game development update - good performance rendering like the SNES</h1>
<p>With past projects, it was default for me to think that to obtain a good rendering performance, even for 2D games, was to use GPU-based rendering. It is the default to think that for almost everyone if you search on the internet. Well, but I was frustrated and I could no accept that. I implemented a software rendering system for rendering tiles that is similar to the one of the SNES and obtained very satisfying results. Of course, rendering on the SNES is hardware-based, but with modern CPUs, I could not believe that software rendering could not reach the performance of the SNES. The system that I implemented can draw 16 layers, each with 30 x 20 tiles (600 tiles in each layer, 9600 tiles total), and each tile with 16 x 16 of size, and the frame rate is still 60 frames per second. It is much more than what I expected on an average laptop (processor Intel i3), so it is a good thing. I am currently using it to make a game unannounced, but I will keep this system also for future projects.</p>
<figure>
<img src="./pictures/rendering_layers.png" />
</figure>
<p>It is worth noting that the pictures of the tiles, and the layers are in a format of indexed color palette. This helps the performance. Only at the final step of rendering the view on the screen that the composed picture of the view is rendered using the indexed color palette to the RGBA screen.</p>
<p>I will leave to you the weight of each advantage and disadvantage.</p>
<h2>The advantages</h2>
<ol>
<li>The code is very portable. It would work on any desktop OS or any console, and only the final step of rendering on the screen would need to be ported.</li>
<li>It is much simpler to work with this than working with graphical APIs for GPUs. For example, OpenGL not only has many versions that break compatibility, but the same version in different platforms is not guaranteed to have all features of that version implemented.</li>
<li>Performance, as mentioned above.</li>
<li>Color palette swap is easy.</li>
</ol>
<h2>The disadvantages</h2>
<ol>
<li>Limited to a color palette.</li>
<li>Pictures must be of 16 x 16 size or composed of multiple pictures of 16 x 16 size.</li>
<li>Run-time operations such as scaling and rotation are difficult to be implemented.</li>
</ol>
<h2>Final words</h2>
<p>If I remember more advantages or disadvantages I will update this list. But, the lesson here is that not always the default collective mindset is correct. For the kind o project that I am doing, software rendering on a considerable resolution for a 2D game (480 x 320) had an efficient performance with frame rate of 60 frames per second.</p>
<h2>Reference</h2>
<ol>
<li><a target="_blank" href="https://wiki.superfamicom.org/backgrounds">https://wiki.superfamicom.org/backgrounds</a></li>
<li><a target="_blank" href="https://megacatstudios.com/blogs/press/super-nintendo-graphic-guide<">https://megacatstudios.com/blogs/press/super-nintendo-graphic-guide</a></li>
<li><a target="_blank" href="https://en.wikibooks.org/wiki/Super_NES_Programming/Graphics_tutorial<">https://en.wikibooks.org/wiki/Super_NES_Programming/Graphics_tutorial</a></li>
</ol>
</article>
<footer>
<p>Copyright &copy; Felipe Ferreira da Silva. All rights reserved.</p>
</footer>
</body>
</html>
